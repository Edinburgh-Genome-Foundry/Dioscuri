{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Dioscuri Dioscuri is a Python package for working with Gemini WorkList (gwl) files and objects. A Gemini worklist file is a text file that contains pipetting instructions for the Tecan Freedom EVO robots. Dioscuri uses the Freedom EVOware (v2.7) software's specification of the gwl format. Dioscuri is a name for Castor and Pollux, the twins who were transformed into the Gemini constellation in Greek mythology. Install pip install dioscuri Usage import dioscuri aspirate = dioscuri . Pipette ( operation = \"Aspirate\" , rack_label = \"Source1\" , rack_type = \"4ti-0960/B on raised carrier\" , position = \"3\" , volume = \"50\" ) aspirate . to_string () dispense = dioscuri . Pipette ( operation = \"D\" , rack_label = \"Destination\" , rack_type = \"4ti-0960/B on CPAC\" , position = \"1\" , volume = \"50\" ) wash = dioscuri . WashTipOrReplaceDITI () worklist = dioscuri . GeminiWorkList ( name = \"my_worklist\" , records = [ aspirate , dispense , wash ]) worklist . records_to_string () print ( worklist . records_to_string ()) # A;Source1;;4ti-0960/B on raised carrier;3;;50;;;; # D;Destination;;4ti-0960/B on CPAC;1;;50;;;; # W; The worklist can be saved in a text file: worklist . records_to_file ( \"picklist.gwl\" ) A gwl file can also be read into a worklist: worklist = dioscuri . read_gwl ( \"picklist.gwl\" ) Versioning Dioscuri uses the semantic versioning scheme. License = MIT Dioscuri is free software , which means the users have the freedom to run, copy, distribute, study, change and improve the software. Dioscuri was written at the Edinburgh Genome Foundry by Peter Vegh and is released under the MIT license.","title":"Home"},{"location":"#dioscuri","text":"Dioscuri is a Python package for working with Gemini WorkList (gwl) files and objects. A Gemini worklist file is a text file that contains pipetting instructions for the Tecan Freedom EVO robots. Dioscuri uses the Freedom EVOware (v2.7) software's specification of the gwl format. Dioscuri is a name for Castor and Pollux, the twins who were transformed into the Gemini constellation in Greek mythology.","title":"Dioscuri"},{"location":"#install","text":"pip install dioscuri","title":"Install"},{"location":"#usage","text":"import dioscuri aspirate = dioscuri . Pipette ( operation = \"Aspirate\" , rack_label = \"Source1\" , rack_type = \"4ti-0960/B on raised carrier\" , position = \"3\" , volume = \"50\" ) aspirate . to_string () dispense = dioscuri . Pipette ( operation = \"D\" , rack_label = \"Destination\" , rack_type = \"4ti-0960/B on CPAC\" , position = \"1\" , volume = \"50\" ) wash = dioscuri . WashTipOrReplaceDITI () worklist = dioscuri . GeminiWorkList ( name = \"my_worklist\" , records = [ aspirate , dispense , wash ]) worklist . records_to_string () print ( worklist . records_to_string ()) # A;Source1;;4ti-0960/B on raised carrier;3;;50;;;; # D;Destination;;4ti-0960/B on CPAC;1;;50;;;; # W; The worklist can be saved in a text file: worklist . records_to_file ( \"picklist.gwl\" ) A gwl file can also be read into a worklist: worklist = dioscuri . read_gwl ( \"picklist.gwl\" )","title":"Usage"},{"location":"#versioning","text":"Dioscuri uses the semantic versioning scheme.","title":"Versioning"},{"location":"#license-mit","text":"Dioscuri is free software , which means the users have the freedom to run, copy, distribute, study, change and improve the software. Dioscuri was written at the Edinburgh Genome Foundry by Peter Vegh and is released under the MIT license.","title":"License = MIT"},{"location":"reference/dioscuri/","text":"Module dioscuri View Source from .dioscuri import ( GeminiWorkList , Pipette , WashTipOrReplaceDITI , Decontamination , Flush , Break , SetDITIType , Comment , ReagentDistribution , read_gwl , ) from .version import __version__ Sub-modules dioscuri.dioscuri dioscuri.version","title":"Index"},{"location":"reference/dioscuri/#module-dioscuri","text":"View Source from .dioscuri import ( GeminiWorkList , Pipette , WashTipOrReplaceDITI , Decontamination , Flush , Break , SetDITIType , Comment , ReagentDistribution , read_gwl , ) from .version import __version__","title":"Module dioscuri"},{"location":"reference/dioscuri/#sub-modules","text":"dioscuri.dioscuri dioscuri.version","title":"Sub-modules"},{"location":"reference/dioscuri/dioscuri/","text":"Module dioscuri.dioscuri Classes for representing a Gemini WorkList (gwl). The gwl file specification is based on the Freedom EVOware Software Manual, 393172, v3.5 (2015), for the Tecan Freedom EVOware v2.7 software (note different versioning for manual and software). A gwl file is made up of records. A record consists of a single character indicating the operation type, and one or more 'parameters'. DiTi is short for 'Disposable Tip'. View Source \"\"\"Classes for representing a Gemini WorkList (gwl). The gwl file specification is based on the Freedom EVOware Software Manual, 393172, v3.5 (2015), for the Tecan Freedom EVOware v2.7 software (note different versioning for manual and software). A gwl file is made up of records. A record consists of a single character indicating the operation type, and one or more 'parameters'. DiTi is short for 'Disposable Tip'. \"\"\" # The magic character semicolon (;) appearing throughout the script is used as # a separator and is specified by the gwl fileformat. def read_gwl ( filepath ): worklist = GeminiWorkList () with open ( filepath ) as f : records_as_strings = f . read (). splitlines () # read txt lines for record_as_string in records_as_strings : entries = record_as_string . split ( \";\" ) if entries [ 0 ] == \"A\" or entries [ 0 ] == \"D\" : record = Pipette ( operation = entries [ 0 ], rack_label = entries [ 1 ], rack_id = entries [ 2 ], rack_type = entries [ 3 ], position = entries [ 4 ], tube_id = entries [ 5 ], volume = entries [ 6 ], liquid_class = entries [ 7 ], # tip_type is entry #8 tip_mask = entries [ 9 ], forced_rack_type = entries [ 10 ], ) elif entries [ 0 ] == \"W\" : record = WashTipOrReplaceDITI () elif entries [ 0 ] == \"W1\" : record = WashTipOrReplaceDITI ( scheme = 1 ) elif entries [ 0 ] == \"W2\" : record = WashTipOrReplaceDITI ( scheme = 2 ) elif entries [ 0 ] == \"W3\" : record = WashTipOrReplaceDITI ( scheme = 3 ) elif entries [ 0 ] == \"W4\" : record = WashTipOrReplaceDITI ( scheme = 4 ) elif entries [ 0 ] == \"WD\" : record = Decontamination () elif entries [ 0 ] == \"F\" : record = Flush () elif entries [ 0 ] == \"B\" : record = Break () elif entries [ 0 ] == \"S\" : record = SetDITIType ( * entries [ 1 :]) # first one is the record type elif entries [ 0 ] == \"C\" : record = Comment ( * entries [ 1 :]) elif entries [ 0 ] == \"R\" : record = ReagentDistribution ( * entries [ 1 :]) else : raise ValueError ( \"Entry `%s` is not a valid record type.\" % entries [ 0 ]) worklist . add_record ( record ) return worklist class GeminiWorkList : \"\"\"Gemini WorkList (gwl) class. A WorkList is a list of pipetting commands, or 'records'. **Parameters** **name** > name of the worklist (`str`). **records** > `list` of records (Pipette class instances). \"\"\" def __init__ ( self , name = \"worklist\" , records = None ): self . name = name if records is None : self . records = [] else : self . records = records def add_record ( self , record ): \"\"\"Add record. **Parameters** **record** > `Pipette` \"\"\" if not type ( record ) in [ Pipette , WashTipOrReplaceDITI , Decontamination , Flush , Break , SetDITIType , Comment , ReagentDistribution , ]: raise AssertionError ( \"Parameter `record` must be a record class.\" ) if type ( record ) is SetDITIType : if len ( self . records ) != 0 : if type ( self . records [ - 1 ]) != Break : raise ValueError ( \"The Set DiTi Type record can only be used at the very\" \" beginning of the worklist or directly after a Break record.\" ) self . records . append ( record ) def list_records ( self ): record_list = [] for record in self . records : record_list . append ( record . type_character ) return record_list def records_to_string ( self ): records_as_string = \"\" for record in self . records : records_as_string += record . to_string () records_as_string += \"\\n\" return records_as_string def records_to_file ( self , filename ): records_as_string = self . records_to_string () with open ( filename , \"w\" , encoding = \"utf8\" ) as f : f . write ( records_as_string ) class Pipette : \"\"\"General class for Aspirate and Dispense records. Note that parameter MinDetectedVolume is not implemented. **Parameters** **operation** > The type of the transfer (`str`): `A` for aspirate, or `D` for dispense. > The first letter of the specified string is used. **rack_label** > Label (`str`) which is assigned to the labware. Maximum 32 characters. **rack_id** > Labware barcode (`str`). Maximum 32 characters. **rack_type** > Labware type (`str`): configuration name, for example \" 384 Well , landscape \". Maximum 32 characters. **position** > Well position in the labware (`int`). The position starts with 1 and increases from rear to front and left to right. Range: 1 .. number of wells. **tube_id** > Tube barcode (`str`). Maximum 32 characters. **volume** > Pipetting volume (`int`) in \u00b5l (microliter). Range: 0 .. 7158278. **liquid_class** > Optional (`str`). Overwrites the liquid class specified in the Tecan EVOware Worklist command that calls the gwl file. Maximum 32 characters. **tip_mask** > Optional (`str`). Specifies the tip you want to use. See details in the program that uses the gwl output file. Range: 1 .. 128. **forced_rack_type** > Optional (`str`). The configuration name of the labware. Maximum 32 characters. \"\"\" def __init__ ( self , operation , rack_label , rack_type , position , volume , tube_id = \"\" , rack_id = \"\" , liquid_class = \"\" , tip_mask = \"\" , forced_rack_type = \"\" , ): if not operation [ 0 ] in [ \"A\" , \"D\" ]: raise ValueError ( \"Parameter `operation` must be one of 'A' or 'D'.\" ) else : self . type_character = operation [ 0 ] # Parameters: self . rack_label = rack_label self . rack_id = rack_id self . rack_type = rack_type self . position = position self . tube_id = tube_id self . volume = volume self . liquid_class = liquid_class self . tip_mask = tip_mask self . forced_rack_type = forced_rack_type self . tip_type = \"\" # Reserved, must be omitted. def to_string ( self ): # Order is important: parameters = [ self . type_character , self . rack_label , self . rack_id , self . rack_type , str ( self . position ), self . tube_id , str ( self . volume ), self . liquid_class , self . tip_type , self . tip_mask , self . forced_rack_type , ] record_as_string = \";\" . join ( parameters ) return record_as_string class WashTipOrReplaceDITI : \"\"\"Class for WashTip or ReplaceDITI records. **Parameters** **scheme** > Number (`int`) of wash scheme to use. Default `None`, which uses the first wash scheme. \"\"\" def __init__ ( self , scheme = None ): if scheme is None : self . scheme = \"\" else : if scheme not in [ 1 , 2 , 3 , 4 ]: raise ValueError ( \"Scheme must be between 1 and 4.\" ) self . scheme = str ( scheme ) self . type_character = \"W\" def to_string ( self ): \"\"\"Convert record into string representation.\"\"\" record_as_string = self . type_character + self . scheme + \";\" return record_as_string class Decontamination : \"\"\"The Decontamination Wash record.\"\"\" def __init__ ( self ): self . type_character = \"WD\" def to_string ( self ): \"\"\"Convert record into string representation.\"\"\" record_as_string = self . type_character + \";\" return record_as_string class Flush : \"\"\"The Flush record.\"\"\" def __init__ ( self ): self . type_character = \"F\" def to_string ( self ): \"\"\"Convert record into string representation.\"\"\" record_as_string = self . type_character + \";\" return record_as_string class Break : \"\"\"The Break record.\"\"\" def __init__ ( self ): self . type_character = \"B\" def to_string ( self ): \"\"\"Convert record into string representation.\"\"\" record_as_string = self . type_character + \";\" return record_as_string class SetDITIType : \"\"\"The Set DiTi Type record. The Set DiTi Type record can only be used at the very beginning of the worklist or directly after a Break record. **Parameters** **DiTi_Index** > The index of DiTi Type (`str`). Used to switch DiTi types from within a worklist. \"\"\" def __init__ ( self , diti_index ): self . diti_index = diti_index self . type_character = \"S\" def to_string ( self ): \"\"\"Convert record into string representation.\"\"\" parameters = [ self . type_character , self . diti_index ] record_as_string = \";\" . join ( parameters ) return record_as_string class Comment : \"\"\"The Comment record (ignored by Freedom EVOware). **Parameters** **comment** > The comment (`str`). Newlines (`\\\\n`) will be escaped with `\\`. \"\"\" def __init__ ( self , comment ): if \"\\n\" in comment : self . comment = comment . replace ( \"\\n\" , \"\\\\n\" ) else : self . comment = comment self . type_character = \"C\" def to_string ( self ): \"\"\"Convert record into string representation.\"\"\" parameters = [ self . type_character , self . comment ] record_as_string = \";\" . join ( parameters ) return record_as_string class ReagentDistribution : \"\"\"The Reagent Distribution record. **Parameters** **SrcRackLabel** > Label (`str`) of source labware. Maximum 32 characters. **SrcRackID** > Source labware barcode (`str`). Maximum 32 characters. **SrcRackType** > Source labware type (`str`): configuration name. Maximum 32 characters. **SrcPosStart** > First well to be used in the source labware (`int`). Range: 1 .. number of wells. **SrcPosEnd** > Last well to be used in the source labware (`int`). Range: 1 .. number of wells. **DestRackLabel** > Label (`str`) of destination labware. Maximum 32 characters. **DestRackID** > Destination labware barcode (`str`). Maximum 32 characters. **DestRackType** > Destination labware type (`str`): configuration name. Maximum 32 characters. **DestPosStart** > First well to be used in the destination labware (`int`). > Range: 1 .. number of wells. **DestPosEnd** > Last well to be used in the destination labware (`int`). > Range: 1 .. number of wells. **Volume** > Dispense volume (`int`) in the destination labware in \u03bcl (microliter). > Range: 0..7158278. **LiquidClass** > Optional (`str`). Overwrites the liquid class specified in the Tecan EVOware Worklist command. Maximum 32 characters. **NoOfDitiReuses** > Optional (`int`). Maximum number of DiTi reuses allowed > (default 1 = no DiTi reuse). **NoOfMultiDisp** > Optional (`int`). Maximum number of dispenses in a multidispense sequence > (default 1 = no multi-dispense). **Direction** > Optional (`int`). Pipetting direction > (0 = left to right, 1 = right to left; default = 0). **ExcludeDestWell** > Optional (`str`). List of wells in destination labware to be excluded from > pipetting. \"\"\" def __init__ ( self , SrcRackLabel , SrcRackID , SrcRackType , SrcPosStart , SrcPosEnd , DestRackLabel , DestRackID , DestRackType , DestPosStart , DestPosEnd , Volume , LiquidClass = \"\" , NoOfDitiReuses = 1 , NoOfMultiDisp = 1 , Direction = 0 , ExcludeDestWell = \"\" , ): self . type_character = \"R\" self . SrcRackLabel = SrcRackLabel self . SrcRackID = SrcRackID self . SrcRackType = SrcRackType self . SrcPosStart = str ( SrcPosStart ) self . SrcPosEnd = str ( SrcPosEnd ) self . DestRackLabel = DestRackLabel self . DestRackID = DestRackID self . DestRackType = DestRackType self . DestPosStart = str ( DestPosStart ) self . DestPosEnd = str ( DestPosEnd ) self . Volume = str ( Volume ) self . LiquidClass = LiquidClass self . NoOfDitiReuses = str ( NoOfDitiReuses ) self . NoOfMultiDisp = str ( NoOfMultiDisp ) self . Direction = str ( Direction ) self . ExcludeDestWell = ExcludeDestWell def to_string ( self ): # Order is important: parameters = [ self . type_character , self . SrcRackLabel , self . SrcRackID , self . SrcRackType , self . SrcPosStart , self . SrcPosEnd , self . DestRackLabel , self . DestRackID , self . DestRackType , self . DestPosStart , self . DestPosEnd , self . Volume , self . LiquidClass , self . NoOfDitiReuses , self . NoOfMultiDisp , self . Direction , self . ExcludeDestWell , ] record_as_string = \";\" . join ( parameters ) return record_as_string Functions read_gwl def read_gwl ( filepath ) View Source def read_gwl ( filepath ): worklist = GeminiWorkList () with open ( filepath ) as f : records_as_strings = f . read (). splitlines () # read txt lines for record_as_string in records_as_strings : entries = record_as_string . split ( \";\" ) if entries [ 0 ] == \"A\" or entries [ 0 ] == \"D\" : record = Pipette ( operation = entries [ 0 ], rack_label = entries [ 1 ], rack_id = entries [ 2 ], rack_type = entries [ 3 ], position = entries [ 4 ], tube_id = entries [ 5 ], volume = entries [ 6 ], liquid_class = entries [ 7 ], # tip_type is entry # 8 tip_mask = entries [ 9 ], forced_rack_type = entries [ 10 ], ) elif entries [ 0 ] == \"W\" : record = WashTipOrReplaceDITI () elif entries [ 0 ] == \"W1\" : record = WashTipOrReplaceDITI ( scheme = 1 ) elif entries [ 0 ] == \"W2\" : record = WashTipOrReplaceDITI ( scheme = 2 ) elif entries [ 0 ] == \"W3\" : record = WashTipOrReplaceDITI ( scheme = 3 ) elif entries [ 0 ] == \"W4\" : record = WashTipOrReplaceDITI ( scheme = 4 ) elif entries [ 0 ] == \"WD\" : record = Decontamination () elif entries [ 0 ] == \"F\" : record = Flush () elif entries [ 0 ] == \"B\" : record = Break () elif entries [ 0 ] == \"S\" : record = SetDITIType ( * entries [ 1 :]) # first one is the record type elif entries [ 0 ] == \"C\" : record = Comment ( * entries [ 1 :]) elif entries [ 0 ] == \"R\" : record = ReagentDistribution ( * entries [ 1 :]) else : raise ValueError ( \"Entry `%s` is not a valid record type.\" % entries [ 0 ]) worklist . add_record ( record ) return worklist Classes Break class Break ( ) The Break record. View Source class Break: \"\"\"The Break record.\"\"\" def __init__ ( self ): self . type_character = \"B\" def to_string ( self ): \"\"\"Convert record into string representation.\"\"\" record_as_string = self . type_character + \";\" return record_as_string Methods to_string def to_string ( self ) Convert record into string representation. View Source def to_string ( self ): \"\"\"Convert record into string representation.\"\"\" record_as_string = self . type_character + \";\" return record_as_string Comment class Comment ( comment ) The Comment record (ignored by Freedom EVOware). Parameters comment The comment ( str ). Newlines ( \\n ) will be escaped with \\ . View Source class Comment : \"\"\"The Comment record (ignored by Freedom EVOware). **Parameters** **comment** > The comment (`str`). Newlines (`\\\\n`) will be escaped with `\\`. \"\"\" def __init__ ( self , comment ): if \"\\n\" in comment : self . comment = comment . replace ( \"\\n\" , \"\\\\n\" ) else : self . comment = comment self . type_character = \"C\" def to_string ( self ): \"\"\"Convert record into string representation.\"\"\" parameters = [ self . type_character , self . comment ] record_as_string = \";\" . join ( parameters ) return record_as_string Methods to_string def to_string ( self ) Convert record into string representation. View Source def to_string ( self ): \"\"\"Convert record into string representation.\"\"\" parameters = [ self . type_character , self . comment ] record_as_string = \";\" . join ( parameters ) return record_as_string Decontamination class Decontamination ( ) The Decontamination Wash record. View Source class Decontamination: \"\"\"The Decontamination Wash record.\"\"\" def __init__ ( self ): self . type_character = \"WD\" def to_string ( self ): \"\"\"Convert record into string representation.\"\"\" record_as_string = self . type_character + \";\" return record_as_string Methods to_string def to_string ( self ) Convert record into string representation. View Source def to_string ( self ): \"\"\"Convert record into string representation.\"\"\" record_as_string = self . type_character + \";\" return record_as_string Flush class Flush ( ) The Flush record. View Source class Flush: \"\"\"The Flush record.\"\"\" def __init__ ( self ): self . type_character = \"F\" def to_string ( self ): \"\"\"Convert record into string representation.\"\"\" record_as_string = self . type_character + \";\" return record_as_string Methods to_string def to_string ( self ) Convert record into string representation. View Source def to_string ( self ): \"\"\"Convert record into string representation.\"\"\" record_as_string = self . type_character + \";\" return record_as_string GeminiWorkList class GeminiWorkList ( name = 'worklist' , records = None ) Gemini WorkList (gwl) class. A WorkList is a list of pipetting commands, or 'records'. Parameters name name of the worklist ( str ). records list of records (Pipette class instances). View Source class GeminiWorkList : \"\"\"Gemini WorkList (gwl) class. A WorkList is a list of pipetting commands, or 'records'. **Parameters** **name** > name of the worklist (`str`). **records** > `list` of records (Pipette class instances). \"\"\" def __init__ ( self , name = \"worklist\" , records = None ): self . name = name if records is None : self . records = [] else : self . records = records def add_record ( self , record ): \"\"\"Add record. **Parameters** **record** > `Pipette` \"\"\" if not type ( record ) in [ Pipette , WashTipOrReplaceDITI , Decontamination , Flush , Break , SetDITIType , Comment , ReagentDistribution , ]: raise AssertionError ( \"Parameter `record` must be a record class.\" ) if type ( record ) is SetDITIType : if len ( self . records ) != 0 : if type ( self . records [ - 1 ]) != Break : raise ValueError ( \"The Set DiTi Type record can only be used at the very\" \" beginning of the worklist or directly after a Break record.\" ) self . records . append ( record ) def list_records ( self ): record_list = [] for record in self . records : record_list . append ( record . type_character ) return record_list def records_to_string ( self ): records_as_string = \"\" for record in self . records : records_as_string += record . to_string () records_as_string += \"\\n\" return records_as_string def records_to_file ( self , filename ): records_as_string = self . records_to_string () with open ( filename , \"w\" , encoding = \"utf8\" ) as f : f . write ( records_as_string ) Methods add_record def add_record ( self , record ) Add record. Parameters record Pipette View Source def add_record ( self , record ): \"\"\"Add record. **Parameters** **record** > `Pipette` \"\"\" if not type ( record ) in [ Pipette , WashTipOrReplaceDITI , Decontamination , Flush , Break , SetDITIType , Comment , ReagentDistribution , ]: raise AssertionError ( \"Parameter `record` must be a record class.\" ) if type ( record ) is SetDITIType : if len ( self . records ) != 0 : if type ( self . records [ - 1 ]) != Break : raise ValueError ( \"The Set DiTi Type record can only be used at the very\" \" beginning of the worklist or directly after a Break record.\" ) self . records . append ( record ) list_records def list_records ( self ) View Source def list_records ( self ): record_list = [] for record in self . records : record_list . append ( record . type_character ) return record_list records_to_file def records_to_file ( self , filename ) View Source def records_to_file ( self , filename ): records_as_string = self . records_to_string () with open ( filename , \"w\" , encoding = \"utf8\" ) as f : f . write ( records_as_string ) records_to_string def records_to_string ( self ) View Source def records_to_string ( self ): records_as_string = \"\" for record in self . records : records_as_string += record . to_string () records_as_string += \"\\n\" return records_as_string Pipette class Pipette ( operation , rack_label , rack_type , position , volume , tube_id = '' , rack_id = '' , liquid_class = '' , tip_mask = '' , forced_rack_type = '' ) General class for Aspirate and Dispense records. Note that parameter MinDetectedVolume is not implemented. Parameters operation The type of the transfer ( str ): A for aspirate, or D for dispense. The first letter of the specified string is used. rack_label Label ( str ) which is assigned to the labware. Maximum 32 characters. rack_id Labware barcode ( str ). Maximum 32 characters. rack_type Labware type ( str ): configuration name, for example \"384 Well, landscape\". Maximum 32 characters. position Well position in the labware ( int ). The position starts with 1 and increases from rear to front and left to right. Range: 1 .. number of wells. tube_id Tube barcode ( str ). Maximum 32 characters. volume Pipetting volume ( int ) in \u00b5l (microliter). Range: 0 .. 7158278. liquid_class Optional ( str ). Overwrites the liquid class specified in the Tecan EVOware Worklist command that calls the gwl file. Maximum 32 characters. tip_mask Optional ( str ). Specifies the tip you want to use. See details in the program that uses the gwl output file. Range: 1 .. 128. forced_rack_type Optional ( str ). The configuration name of the labware. Maximum 32 characters. View Source class Pipette : \"\"\"General class for Aspirate and Dispense records. Note that parameter MinDetectedVolume is not implemented. **Parameters** **operation** > The type of the transfer (`str`): `A` for aspirate, or `D` for dispense. > The first letter of the specified string is used. **rack_label** > Label (`str`) which is assigned to the labware. Maximum 32 characters. **rack_id** > Labware barcode (`str`). Maximum 32 characters. **rack_type** > Labware type (`str`): configuration name, for example \" 384 Well , landscape \". Maximum 32 characters. **position** > Well position in the labware (`int`). The position starts with 1 and increases from rear to front and left to right. Range: 1 .. number of wells. **tube_id** > Tube barcode (`str`). Maximum 32 characters. **volume** > Pipetting volume (`int`) in \u00b5l (microliter). Range: 0 .. 7158278. **liquid_class** > Optional (`str`). Overwrites the liquid class specified in the Tecan EVOware Worklist command that calls the gwl file. Maximum 32 characters. **tip_mask** > Optional (`str`). Specifies the tip you want to use. See details in the program that uses the gwl output file. Range: 1 .. 128. **forced_rack_type** > Optional (`str`). The configuration name of the labware. Maximum 32 characters. \"\"\" def __init__ ( self , operation , rack_label , rack_type , position , volume , tube_id = \"\" , rack_id = \"\" , liquid_class = \"\" , tip_mask = \"\" , forced_rack_type = \"\" , ): if not operation [ 0 ] in [ \"A\" , \"D\" ]: raise ValueError ( \"Parameter `operation` must be one of 'A' or 'D'.\" ) else : self . type_character = operation [ 0 ] # Parameters: self . rack_label = rack_label self . rack_id = rack_id self . rack_type = rack_type self . position = position self . tube_id = tube_id self . volume = volume self . liquid_class = liquid_class self . tip_mask = tip_mask self . forced_rack_type = forced_rack_type self . tip_type = \"\" # Reserved, must be omitted. def to_string ( self ): # Order is important: parameters = [ self . type_character , self . rack_label , self . rack_id , self . rack_type , str ( self . position ), self . tube_id , str ( self . volume ), self . liquid_class , self . tip_type , self . tip_mask , self . forced_rack_type , ] record_as_string = \";\" . join ( parameters ) return record_as_string Methods to_string def to_string ( self ) View Source def to_string ( self ): # Order is important : parameters = [ self . type_character , self . rack_label , self . rack_id , self . rack_type , str ( self . position ), self . tube_id , str ( self . volume ), self . liquid_class , self . tip_type , self . tip_mask , self . forced_rack_type , ] record_as_string = \";\" . join ( parameters ) return record_as_string ReagentDistribution class ReagentDistribution ( SrcRackLabel , SrcRackID , SrcRackType , SrcPosStart , SrcPosEnd , DestRackLabel , DestRackID , DestRackType , DestPosStart , DestPosEnd , Volume , LiquidClass = '' , NoOfDitiReuses = 1 , NoOfMultiDisp = 1 , Direction = 0 , ExcludeDestWell = '' ) The Reagent Distribution record. Parameters SrcRackLabel Label ( str ) of source labware. Maximum 32 characters. SrcRackID Source labware barcode ( str ). Maximum 32 characters. SrcRackType Source labware type ( str ): configuration name. Maximum 32 characters. SrcPosStart First well to be used in the source labware ( int ). Range: 1 .. number of wells. SrcPosEnd Last well to be used in the source labware ( int ). Range: 1 .. number of wells. DestRackLabel Label ( str ) of destination labware. Maximum 32 characters. DestRackID Destination labware barcode ( str ). Maximum 32 characters. DestRackType Destination labware type ( str ): configuration name. Maximum 32 characters. DestPosStart First well to be used in the destination labware ( int ). Range: 1 .. number of wells. DestPosEnd Last well to be used in the destination labware ( int ). Range: 1 .. number of wells. Volume Dispense volume ( int ) in the destination labware in \u03bcl (microliter). Range: 0..7158278. LiquidClass Optional ( str ). Overwrites the liquid class specified in the Tecan EVOware Worklist command. Maximum 32 characters. NoOfDitiReuses Optional ( int ). Maximum number of DiTi reuses allowed (default 1 = no DiTi reuse). NoOfMultiDisp Optional ( int ). Maximum number of dispenses in a multidispense sequence (default 1 = no multi-dispense). Direction Optional ( int ). Pipetting direction (0 = left to right, 1 = right to left; default = 0). ExcludeDestWell Optional ( str ). List of wells in destination labware to be excluded from pipetting. View Source class ReagentDistribution : \"\"\"The Reagent Distribution record. **Parameters** **SrcRackLabel** > Label (`str`) of source labware. Maximum 32 characters. **SrcRackID** > Source labware barcode (`str`). Maximum 32 characters. **SrcRackType** > Source labware type (`str`): configuration name. Maximum 32 characters. **SrcPosStart** > First well to be used in the source labware (`int`). Range: 1 .. number of wells. **SrcPosEnd** > Last well to be used in the source labware (`int`). Range: 1 .. number of wells. **DestRackLabel** > Label (`str`) of destination labware. Maximum 32 characters. **DestRackID** > Destination labware barcode (`str`). Maximum 32 characters. **DestRackType** > Destination labware type (`str`): configuration name. Maximum 32 characters. **DestPosStart** > First well to be used in the destination labware (`int`). > Range: 1 .. number of wells. **DestPosEnd** > Last well to be used in the destination labware (`int`). > Range: 1 .. number of wells. **Volume** > Dispense volume (`int`) in the destination labware in \u03bcl (microliter). > Range: 0..7158278. **LiquidClass** > Optional (`str`). Overwrites the liquid class specified in the Tecan EVOware Worklist command. Maximum 32 characters. **NoOfDitiReuses** > Optional (`int`). Maximum number of DiTi reuses allowed > (default 1 = no DiTi reuse). **NoOfMultiDisp** > Optional (`int`). Maximum number of dispenses in a multidispense sequence > (default 1 = no multi-dispense). **Direction** > Optional (`int`). Pipetting direction > (0 = left to right, 1 = right to left; default = 0). **ExcludeDestWell** > Optional (`str`). List of wells in destination labware to be excluded from > pipetting. \"\"\" def __init__ ( self , SrcRackLabel , SrcRackID , SrcRackType , SrcPosStart , SrcPosEnd , DestRackLabel , DestRackID , DestRackType , DestPosStart , DestPosEnd , Volume , LiquidClass = \"\" , NoOfDitiReuses = 1 , NoOfMultiDisp = 1 , Direction = 0 , ExcludeDestWell = \"\" , ): self . type_character = \"R\" self . SrcRackLabel = SrcRackLabel self . SrcRackID = SrcRackID self . SrcRackType = SrcRackType self . SrcPosStart = str ( SrcPosStart ) self . SrcPosEnd = str ( SrcPosEnd ) self . DestRackLabel = DestRackLabel self . DestRackID = DestRackID self . DestRackType = DestRackType self . DestPosStart = str ( DestPosStart ) self . DestPosEnd = str ( DestPosEnd ) self . Volume = str ( Volume ) self . LiquidClass = LiquidClass self . NoOfDitiReuses = str ( NoOfDitiReuses ) self . NoOfMultiDisp = str ( NoOfMultiDisp ) self . Direction = str ( Direction ) self . ExcludeDestWell = ExcludeDestWell def to_string ( self ): # Order is important: parameters = [ self . type_character , self . SrcRackLabel , self . SrcRackID , self . SrcRackType , self . SrcPosStart , self . SrcPosEnd , self . DestRackLabel , self . DestRackID , self . DestRackType , self . DestPosStart , self . DestPosEnd , self . Volume , self . LiquidClass , self . NoOfDitiReuses , self . NoOfMultiDisp , self . Direction , self . ExcludeDestWell , ] record_as_string = \";\" . join ( parameters ) return record_as_string Methods to_string def to_string ( self ) View Source def to_string ( self ): # Order is important : parameters = [ self . type_character , self . SrcRackLabel , self . SrcRackID , self . SrcRackType , self . SrcPosStart , self . SrcPosEnd , self . DestRackLabel , self . DestRackID , self . DestRackType , self . DestPosStart , self . DestPosEnd , self . Volume , self . LiquidClass , self . NoOfDitiReuses , self . NoOfMultiDisp , self . Direction , self . ExcludeDestWell , ] record_as_string = \";\" . join ( parameters ) return record_as_string SetDITIType class SetDITIType ( diti_index ) The Set DiTi Type record. The Set DiTi Type record can only be used at the very beginning of the worklist or directly after a Break record. Parameters DiTi_Index The index of DiTi Type ( str ). Used to switch DiTi types from within a worklist. View Source class SetDITIType : \"\"\"The Set DiTi Type record. The Set DiTi Type record can only be used at the very beginning of the worklist or directly after a Break record. **Parameters** **DiTi_Index** > The index of DiTi Type (`str`). Used to switch DiTi types from within a worklist. \"\"\" def __init__ ( self , diti_index ): self . diti_index = diti_index self . type_character = \"S\" def to_string ( self ): \"\"\"Convert record into string representation.\"\"\" parameters = [ self . type_character , self . diti_index ] record_as_string = \";\" . join ( parameters ) return record_as_string Methods to_string def to_string ( self ) Convert record into string representation. View Source def to_string ( self ): \"\"\"Convert record into string representation.\"\"\" parameters = [ self . type_character , self . diti_index ] record_as_string = \";\" . join ( parameters ) return record_as_string WashTipOrReplaceDITI class WashTipOrReplaceDITI ( scheme = None ) Class for WashTip or ReplaceDITI records. Parameters scheme Number ( int ) of wash scheme to use. Default None , which uses the first wash scheme. View Source class WashTipOrReplaceDITI : \"\"\"Class for WashTip or ReplaceDITI records. **Parameters** **scheme** > Number (`int`) of wash scheme to use. Default `None`, which uses the first wash scheme. \"\"\" def __init__ ( self , scheme = None ): if scheme is None : self . scheme = \"\" else : if scheme not in [ 1 , 2 , 3 , 4 ]: raise ValueError ( \"Scheme must be between 1 and 4.\" ) self . scheme = str ( scheme ) self . type_character = \"W\" def to_string ( self ): \"\"\"Convert record into string representation.\"\"\" record_as_string = self . type_character + self . scheme + \";\" return record_as_string Methods to_string def to_string ( self ) Convert record into string representation. View Source def to_string ( self ): \"\"\"Convert record into string representation.\"\"\" record_as_string = self . type_character + self . scheme + \";\" return record_as_string","title":"Dioscuri"},{"location":"reference/dioscuri/dioscuri/#module-dioscuridioscuri","text":"Classes for representing a Gemini WorkList (gwl). The gwl file specification is based on the Freedom EVOware Software Manual, 393172, v3.5 (2015), for the Tecan Freedom EVOware v2.7 software (note different versioning for manual and software). A gwl file is made up of records. A record consists of a single character indicating the operation type, and one or more 'parameters'. DiTi is short for 'Disposable Tip'. View Source \"\"\"Classes for representing a Gemini WorkList (gwl). The gwl file specification is based on the Freedom EVOware Software Manual, 393172, v3.5 (2015), for the Tecan Freedom EVOware v2.7 software (note different versioning for manual and software). A gwl file is made up of records. A record consists of a single character indicating the operation type, and one or more 'parameters'. DiTi is short for 'Disposable Tip'. \"\"\" # The magic character semicolon (;) appearing throughout the script is used as # a separator and is specified by the gwl fileformat. def read_gwl ( filepath ): worklist = GeminiWorkList () with open ( filepath ) as f : records_as_strings = f . read (). splitlines () # read txt lines for record_as_string in records_as_strings : entries = record_as_string . split ( \";\" ) if entries [ 0 ] == \"A\" or entries [ 0 ] == \"D\" : record = Pipette ( operation = entries [ 0 ], rack_label = entries [ 1 ], rack_id = entries [ 2 ], rack_type = entries [ 3 ], position = entries [ 4 ], tube_id = entries [ 5 ], volume = entries [ 6 ], liquid_class = entries [ 7 ], # tip_type is entry #8 tip_mask = entries [ 9 ], forced_rack_type = entries [ 10 ], ) elif entries [ 0 ] == \"W\" : record = WashTipOrReplaceDITI () elif entries [ 0 ] == \"W1\" : record = WashTipOrReplaceDITI ( scheme = 1 ) elif entries [ 0 ] == \"W2\" : record = WashTipOrReplaceDITI ( scheme = 2 ) elif entries [ 0 ] == \"W3\" : record = WashTipOrReplaceDITI ( scheme = 3 ) elif entries [ 0 ] == \"W4\" : record = WashTipOrReplaceDITI ( scheme = 4 ) elif entries [ 0 ] == \"WD\" : record = Decontamination () elif entries [ 0 ] == \"F\" : record = Flush () elif entries [ 0 ] == \"B\" : record = Break () elif entries [ 0 ] == \"S\" : record = SetDITIType ( * entries [ 1 :]) # first one is the record type elif entries [ 0 ] == \"C\" : record = Comment ( * entries [ 1 :]) elif entries [ 0 ] == \"R\" : record = ReagentDistribution ( * entries [ 1 :]) else : raise ValueError ( \"Entry `%s` is not a valid record type.\" % entries [ 0 ]) worklist . add_record ( record ) return worklist class GeminiWorkList : \"\"\"Gemini WorkList (gwl) class. A WorkList is a list of pipetting commands, or 'records'. **Parameters** **name** > name of the worklist (`str`). **records** > `list` of records (Pipette class instances). \"\"\" def __init__ ( self , name = \"worklist\" , records = None ): self . name = name if records is None : self . records = [] else : self . records = records def add_record ( self , record ): \"\"\"Add record. **Parameters** **record** > `Pipette` \"\"\" if not type ( record ) in [ Pipette , WashTipOrReplaceDITI , Decontamination , Flush , Break , SetDITIType , Comment , ReagentDistribution , ]: raise AssertionError ( \"Parameter `record` must be a record class.\" ) if type ( record ) is SetDITIType : if len ( self . records ) != 0 : if type ( self . records [ - 1 ]) != Break : raise ValueError ( \"The Set DiTi Type record can only be used at the very\" \" beginning of the worklist or directly after a Break record.\" ) self . records . append ( record ) def list_records ( self ): record_list = [] for record in self . records : record_list . append ( record . type_character ) return record_list def records_to_string ( self ): records_as_string = \"\" for record in self . records : records_as_string += record . to_string () records_as_string += \"\\n\" return records_as_string def records_to_file ( self , filename ): records_as_string = self . records_to_string () with open ( filename , \"w\" , encoding = \"utf8\" ) as f : f . write ( records_as_string ) class Pipette : \"\"\"General class for Aspirate and Dispense records. Note that parameter MinDetectedVolume is not implemented. **Parameters** **operation** > The type of the transfer (`str`): `A` for aspirate, or `D` for dispense. > The first letter of the specified string is used. **rack_label** > Label (`str`) which is assigned to the labware. Maximum 32 characters. **rack_id** > Labware barcode (`str`). Maximum 32 characters. **rack_type** > Labware type (`str`): configuration name, for example \" 384 Well , landscape \". Maximum 32 characters. **position** > Well position in the labware (`int`). The position starts with 1 and increases from rear to front and left to right. Range: 1 .. number of wells. **tube_id** > Tube barcode (`str`). Maximum 32 characters. **volume** > Pipetting volume (`int`) in \u00b5l (microliter). Range: 0 .. 7158278. **liquid_class** > Optional (`str`). Overwrites the liquid class specified in the Tecan EVOware Worklist command that calls the gwl file. Maximum 32 characters. **tip_mask** > Optional (`str`). Specifies the tip you want to use. See details in the program that uses the gwl output file. Range: 1 .. 128. **forced_rack_type** > Optional (`str`). The configuration name of the labware. Maximum 32 characters. \"\"\" def __init__ ( self , operation , rack_label , rack_type , position , volume , tube_id = \"\" , rack_id = \"\" , liquid_class = \"\" , tip_mask = \"\" , forced_rack_type = \"\" , ): if not operation [ 0 ] in [ \"A\" , \"D\" ]: raise ValueError ( \"Parameter `operation` must be one of 'A' or 'D'.\" ) else : self . type_character = operation [ 0 ] # Parameters: self . rack_label = rack_label self . rack_id = rack_id self . rack_type = rack_type self . position = position self . tube_id = tube_id self . volume = volume self . liquid_class = liquid_class self . tip_mask = tip_mask self . forced_rack_type = forced_rack_type self . tip_type = \"\" # Reserved, must be omitted. def to_string ( self ): # Order is important: parameters = [ self . type_character , self . rack_label , self . rack_id , self . rack_type , str ( self . position ), self . tube_id , str ( self . volume ), self . liquid_class , self . tip_type , self . tip_mask , self . forced_rack_type , ] record_as_string = \";\" . join ( parameters ) return record_as_string class WashTipOrReplaceDITI : \"\"\"Class for WashTip or ReplaceDITI records. **Parameters** **scheme** > Number (`int`) of wash scheme to use. Default `None`, which uses the first wash scheme. \"\"\" def __init__ ( self , scheme = None ): if scheme is None : self . scheme = \"\" else : if scheme not in [ 1 , 2 , 3 , 4 ]: raise ValueError ( \"Scheme must be between 1 and 4.\" ) self . scheme = str ( scheme ) self . type_character = \"W\" def to_string ( self ): \"\"\"Convert record into string representation.\"\"\" record_as_string = self . type_character + self . scheme + \";\" return record_as_string class Decontamination : \"\"\"The Decontamination Wash record.\"\"\" def __init__ ( self ): self . type_character = \"WD\" def to_string ( self ): \"\"\"Convert record into string representation.\"\"\" record_as_string = self . type_character + \";\" return record_as_string class Flush : \"\"\"The Flush record.\"\"\" def __init__ ( self ): self . type_character = \"F\" def to_string ( self ): \"\"\"Convert record into string representation.\"\"\" record_as_string = self . type_character + \";\" return record_as_string class Break : \"\"\"The Break record.\"\"\" def __init__ ( self ): self . type_character = \"B\" def to_string ( self ): \"\"\"Convert record into string representation.\"\"\" record_as_string = self . type_character + \";\" return record_as_string class SetDITIType : \"\"\"The Set DiTi Type record. The Set DiTi Type record can only be used at the very beginning of the worklist or directly after a Break record. **Parameters** **DiTi_Index** > The index of DiTi Type (`str`). Used to switch DiTi types from within a worklist. \"\"\" def __init__ ( self , diti_index ): self . diti_index = diti_index self . type_character = \"S\" def to_string ( self ): \"\"\"Convert record into string representation.\"\"\" parameters = [ self . type_character , self . diti_index ] record_as_string = \";\" . join ( parameters ) return record_as_string class Comment : \"\"\"The Comment record (ignored by Freedom EVOware). **Parameters** **comment** > The comment (`str`). Newlines (`\\\\n`) will be escaped with `\\`. \"\"\" def __init__ ( self , comment ): if \"\\n\" in comment : self . comment = comment . replace ( \"\\n\" , \"\\\\n\" ) else : self . comment = comment self . type_character = \"C\" def to_string ( self ): \"\"\"Convert record into string representation.\"\"\" parameters = [ self . type_character , self . comment ] record_as_string = \";\" . join ( parameters ) return record_as_string class ReagentDistribution : \"\"\"The Reagent Distribution record. **Parameters** **SrcRackLabel** > Label (`str`) of source labware. Maximum 32 characters. **SrcRackID** > Source labware barcode (`str`). Maximum 32 characters. **SrcRackType** > Source labware type (`str`): configuration name. Maximum 32 characters. **SrcPosStart** > First well to be used in the source labware (`int`). Range: 1 .. number of wells. **SrcPosEnd** > Last well to be used in the source labware (`int`). Range: 1 .. number of wells. **DestRackLabel** > Label (`str`) of destination labware. Maximum 32 characters. **DestRackID** > Destination labware barcode (`str`). Maximum 32 characters. **DestRackType** > Destination labware type (`str`): configuration name. Maximum 32 characters. **DestPosStart** > First well to be used in the destination labware (`int`). > Range: 1 .. number of wells. **DestPosEnd** > Last well to be used in the destination labware (`int`). > Range: 1 .. number of wells. **Volume** > Dispense volume (`int`) in the destination labware in \u03bcl (microliter). > Range: 0..7158278. **LiquidClass** > Optional (`str`). Overwrites the liquid class specified in the Tecan EVOware Worklist command. Maximum 32 characters. **NoOfDitiReuses** > Optional (`int`). Maximum number of DiTi reuses allowed > (default 1 = no DiTi reuse). **NoOfMultiDisp** > Optional (`int`). Maximum number of dispenses in a multidispense sequence > (default 1 = no multi-dispense). **Direction** > Optional (`int`). Pipetting direction > (0 = left to right, 1 = right to left; default = 0). **ExcludeDestWell** > Optional (`str`). List of wells in destination labware to be excluded from > pipetting. \"\"\" def __init__ ( self , SrcRackLabel , SrcRackID , SrcRackType , SrcPosStart , SrcPosEnd , DestRackLabel , DestRackID , DestRackType , DestPosStart , DestPosEnd , Volume , LiquidClass = \"\" , NoOfDitiReuses = 1 , NoOfMultiDisp = 1 , Direction = 0 , ExcludeDestWell = \"\" , ): self . type_character = \"R\" self . SrcRackLabel = SrcRackLabel self . SrcRackID = SrcRackID self . SrcRackType = SrcRackType self . SrcPosStart = str ( SrcPosStart ) self . SrcPosEnd = str ( SrcPosEnd ) self . DestRackLabel = DestRackLabel self . DestRackID = DestRackID self . DestRackType = DestRackType self . DestPosStart = str ( DestPosStart ) self . DestPosEnd = str ( DestPosEnd ) self . Volume = str ( Volume ) self . LiquidClass = LiquidClass self . NoOfDitiReuses = str ( NoOfDitiReuses ) self . NoOfMultiDisp = str ( NoOfMultiDisp ) self . Direction = str ( Direction ) self . ExcludeDestWell = ExcludeDestWell def to_string ( self ): # Order is important: parameters = [ self . type_character , self . SrcRackLabel , self . SrcRackID , self . SrcRackType , self . SrcPosStart , self . SrcPosEnd , self . DestRackLabel , self . DestRackID , self . DestRackType , self . DestPosStart , self . DestPosEnd , self . Volume , self . LiquidClass , self . NoOfDitiReuses , self . NoOfMultiDisp , self . Direction , self . ExcludeDestWell , ] record_as_string = \";\" . join ( parameters ) return record_as_string","title":"Module dioscuri.dioscuri"},{"location":"reference/dioscuri/dioscuri/#functions","text":"","title":"Functions"},{"location":"reference/dioscuri/dioscuri/#read_gwl","text":"def read_gwl ( filepath ) View Source def read_gwl ( filepath ): worklist = GeminiWorkList () with open ( filepath ) as f : records_as_strings = f . read (). splitlines () # read txt lines for record_as_string in records_as_strings : entries = record_as_string . split ( \";\" ) if entries [ 0 ] == \"A\" or entries [ 0 ] == \"D\" : record = Pipette ( operation = entries [ 0 ], rack_label = entries [ 1 ], rack_id = entries [ 2 ], rack_type = entries [ 3 ], position = entries [ 4 ], tube_id = entries [ 5 ], volume = entries [ 6 ], liquid_class = entries [ 7 ], # tip_type is entry # 8 tip_mask = entries [ 9 ], forced_rack_type = entries [ 10 ], ) elif entries [ 0 ] == \"W\" : record = WashTipOrReplaceDITI () elif entries [ 0 ] == \"W1\" : record = WashTipOrReplaceDITI ( scheme = 1 ) elif entries [ 0 ] == \"W2\" : record = WashTipOrReplaceDITI ( scheme = 2 ) elif entries [ 0 ] == \"W3\" : record = WashTipOrReplaceDITI ( scheme = 3 ) elif entries [ 0 ] == \"W4\" : record = WashTipOrReplaceDITI ( scheme = 4 ) elif entries [ 0 ] == \"WD\" : record = Decontamination () elif entries [ 0 ] == \"F\" : record = Flush () elif entries [ 0 ] == \"B\" : record = Break () elif entries [ 0 ] == \"S\" : record = SetDITIType ( * entries [ 1 :]) # first one is the record type elif entries [ 0 ] == \"C\" : record = Comment ( * entries [ 1 :]) elif entries [ 0 ] == \"R\" : record = ReagentDistribution ( * entries [ 1 :]) else : raise ValueError ( \"Entry `%s` is not a valid record type.\" % entries [ 0 ]) worklist . add_record ( record ) return worklist","title":"read_gwl"},{"location":"reference/dioscuri/dioscuri/#classes","text":"","title":"Classes"},{"location":"reference/dioscuri/dioscuri/#break","text":"class Break ( ) The Break record. View Source class Break: \"\"\"The Break record.\"\"\" def __init__ ( self ): self . type_character = \"B\" def to_string ( self ): \"\"\"Convert record into string representation.\"\"\" record_as_string = self . type_character + \";\" return record_as_string","title":"Break"},{"location":"reference/dioscuri/dioscuri/#methods","text":"","title":"Methods"},{"location":"reference/dioscuri/dioscuri/#to_string","text":"def to_string ( self ) Convert record into string representation. View Source def to_string ( self ): \"\"\"Convert record into string representation.\"\"\" record_as_string = self . type_character + \";\" return record_as_string","title":"to_string"},{"location":"reference/dioscuri/dioscuri/#comment","text":"class Comment ( comment ) The Comment record (ignored by Freedom EVOware). Parameters comment The comment ( str ). Newlines ( \\n ) will be escaped with \\ . View Source class Comment : \"\"\"The Comment record (ignored by Freedom EVOware). **Parameters** **comment** > The comment (`str`). Newlines (`\\\\n`) will be escaped with `\\`. \"\"\" def __init__ ( self , comment ): if \"\\n\" in comment : self . comment = comment . replace ( \"\\n\" , \"\\\\n\" ) else : self . comment = comment self . type_character = \"C\" def to_string ( self ): \"\"\"Convert record into string representation.\"\"\" parameters = [ self . type_character , self . comment ] record_as_string = \";\" . join ( parameters ) return record_as_string","title":"Comment"},{"location":"reference/dioscuri/dioscuri/#methods_1","text":"","title":"Methods"},{"location":"reference/dioscuri/dioscuri/#to_string_1","text":"def to_string ( self ) Convert record into string representation. View Source def to_string ( self ): \"\"\"Convert record into string representation.\"\"\" parameters = [ self . type_character , self . comment ] record_as_string = \";\" . join ( parameters ) return record_as_string","title":"to_string"},{"location":"reference/dioscuri/dioscuri/#decontamination","text":"class Decontamination ( ) The Decontamination Wash record. View Source class Decontamination: \"\"\"The Decontamination Wash record.\"\"\" def __init__ ( self ): self . type_character = \"WD\" def to_string ( self ): \"\"\"Convert record into string representation.\"\"\" record_as_string = self . type_character + \";\" return record_as_string","title":"Decontamination"},{"location":"reference/dioscuri/dioscuri/#methods_2","text":"","title":"Methods"},{"location":"reference/dioscuri/dioscuri/#to_string_2","text":"def to_string ( self ) Convert record into string representation. View Source def to_string ( self ): \"\"\"Convert record into string representation.\"\"\" record_as_string = self . type_character + \";\" return record_as_string","title":"to_string"},{"location":"reference/dioscuri/dioscuri/#flush","text":"class Flush ( ) The Flush record. View Source class Flush: \"\"\"The Flush record.\"\"\" def __init__ ( self ): self . type_character = \"F\" def to_string ( self ): \"\"\"Convert record into string representation.\"\"\" record_as_string = self . type_character + \";\" return record_as_string","title":"Flush"},{"location":"reference/dioscuri/dioscuri/#methods_3","text":"","title":"Methods"},{"location":"reference/dioscuri/dioscuri/#to_string_3","text":"def to_string ( self ) Convert record into string representation. View Source def to_string ( self ): \"\"\"Convert record into string representation.\"\"\" record_as_string = self . type_character + \";\" return record_as_string","title":"to_string"},{"location":"reference/dioscuri/dioscuri/#geminiworklist","text":"class GeminiWorkList ( name = 'worklist' , records = None ) Gemini WorkList (gwl) class. A WorkList is a list of pipetting commands, or 'records'. Parameters name name of the worklist ( str ). records list of records (Pipette class instances). View Source class GeminiWorkList : \"\"\"Gemini WorkList (gwl) class. A WorkList is a list of pipetting commands, or 'records'. **Parameters** **name** > name of the worklist (`str`). **records** > `list` of records (Pipette class instances). \"\"\" def __init__ ( self , name = \"worklist\" , records = None ): self . name = name if records is None : self . records = [] else : self . records = records def add_record ( self , record ): \"\"\"Add record. **Parameters** **record** > `Pipette` \"\"\" if not type ( record ) in [ Pipette , WashTipOrReplaceDITI , Decontamination , Flush , Break , SetDITIType , Comment , ReagentDistribution , ]: raise AssertionError ( \"Parameter `record` must be a record class.\" ) if type ( record ) is SetDITIType : if len ( self . records ) != 0 : if type ( self . records [ - 1 ]) != Break : raise ValueError ( \"The Set DiTi Type record can only be used at the very\" \" beginning of the worklist or directly after a Break record.\" ) self . records . append ( record ) def list_records ( self ): record_list = [] for record in self . records : record_list . append ( record . type_character ) return record_list def records_to_string ( self ): records_as_string = \"\" for record in self . records : records_as_string += record . to_string () records_as_string += \"\\n\" return records_as_string def records_to_file ( self , filename ): records_as_string = self . records_to_string () with open ( filename , \"w\" , encoding = \"utf8\" ) as f : f . write ( records_as_string )","title":"GeminiWorkList"},{"location":"reference/dioscuri/dioscuri/#methods_4","text":"","title":"Methods"},{"location":"reference/dioscuri/dioscuri/#add_record","text":"def add_record ( self , record ) Add record. Parameters record Pipette View Source def add_record ( self , record ): \"\"\"Add record. **Parameters** **record** > `Pipette` \"\"\" if not type ( record ) in [ Pipette , WashTipOrReplaceDITI , Decontamination , Flush , Break , SetDITIType , Comment , ReagentDistribution , ]: raise AssertionError ( \"Parameter `record` must be a record class.\" ) if type ( record ) is SetDITIType : if len ( self . records ) != 0 : if type ( self . records [ - 1 ]) != Break : raise ValueError ( \"The Set DiTi Type record can only be used at the very\" \" beginning of the worklist or directly after a Break record.\" ) self . records . append ( record )","title":"add_record"},{"location":"reference/dioscuri/dioscuri/#list_records","text":"def list_records ( self ) View Source def list_records ( self ): record_list = [] for record in self . records : record_list . append ( record . type_character ) return record_list","title":"list_records"},{"location":"reference/dioscuri/dioscuri/#records_to_file","text":"def records_to_file ( self , filename ) View Source def records_to_file ( self , filename ): records_as_string = self . records_to_string () with open ( filename , \"w\" , encoding = \"utf8\" ) as f : f . write ( records_as_string )","title":"records_to_file"},{"location":"reference/dioscuri/dioscuri/#records_to_string","text":"def records_to_string ( self ) View Source def records_to_string ( self ): records_as_string = \"\" for record in self . records : records_as_string += record . to_string () records_as_string += \"\\n\" return records_as_string","title":"records_to_string"},{"location":"reference/dioscuri/dioscuri/#pipette","text":"class Pipette ( operation , rack_label , rack_type , position , volume , tube_id = '' , rack_id = '' , liquid_class = '' , tip_mask = '' , forced_rack_type = '' ) General class for Aspirate and Dispense records. Note that parameter MinDetectedVolume is not implemented. Parameters operation The type of the transfer ( str ): A for aspirate, or D for dispense. The first letter of the specified string is used. rack_label Label ( str ) which is assigned to the labware. Maximum 32 characters. rack_id Labware barcode ( str ). Maximum 32 characters. rack_type Labware type ( str ): configuration name, for example \"384 Well, landscape\". Maximum 32 characters. position Well position in the labware ( int ). The position starts with 1 and increases from rear to front and left to right. Range: 1 .. number of wells. tube_id Tube barcode ( str ). Maximum 32 characters. volume Pipetting volume ( int ) in \u00b5l (microliter). Range: 0 .. 7158278. liquid_class Optional ( str ). Overwrites the liquid class specified in the Tecan EVOware Worklist command that calls the gwl file. Maximum 32 characters. tip_mask Optional ( str ). Specifies the tip you want to use. See details in the program that uses the gwl output file. Range: 1 .. 128. forced_rack_type Optional ( str ). The configuration name of the labware. Maximum 32 characters. View Source class Pipette : \"\"\"General class for Aspirate and Dispense records. Note that parameter MinDetectedVolume is not implemented. **Parameters** **operation** > The type of the transfer (`str`): `A` for aspirate, or `D` for dispense. > The first letter of the specified string is used. **rack_label** > Label (`str`) which is assigned to the labware. Maximum 32 characters. **rack_id** > Labware barcode (`str`). Maximum 32 characters. **rack_type** > Labware type (`str`): configuration name, for example \" 384 Well , landscape \". Maximum 32 characters. **position** > Well position in the labware (`int`). The position starts with 1 and increases from rear to front and left to right. Range: 1 .. number of wells. **tube_id** > Tube barcode (`str`). Maximum 32 characters. **volume** > Pipetting volume (`int`) in \u00b5l (microliter). Range: 0 .. 7158278. **liquid_class** > Optional (`str`). Overwrites the liquid class specified in the Tecan EVOware Worklist command that calls the gwl file. Maximum 32 characters. **tip_mask** > Optional (`str`). Specifies the tip you want to use. See details in the program that uses the gwl output file. Range: 1 .. 128. **forced_rack_type** > Optional (`str`). The configuration name of the labware. Maximum 32 characters. \"\"\" def __init__ ( self , operation , rack_label , rack_type , position , volume , tube_id = \"\" , rack_id = \"\" , liquid_class = \"\" , tip_mask = \"\" , forced_rack_type = \"\" , ): if not operation [ 0 ] in [ \"A\" , \"D\" ]: raise ValueError ( \"Parameter `operation` must be one of 'A' or 'D'.\" ) else : self . type_character = operation [ 0 ] # Parameters: self . rack_label = rack_label self . rack_id = rack_id self . rack_type = rack_type self . position = position self . tube_id = tube_id self . volume = volume self . liquid_class = liquid_class self . tip_mask = tip_mask self . forced_rack_type = forced_rack_type self . tip_type = \"\" # Reserved, must be omitted. def to_string ( self ): # Order is important: parameters = [ self . type_character , self . rack_label , self . rack_id , self . rack_type , str ( self . position ), self . tube_id , str ( self . volume ), self . liquid_class , self . tip_type , self . tip_mask , self . forced_rack_type , ] record_as_string = \";\" . join ( parameters ) return record_as_string","title":"Pipette"},{"location":"reference/dioscuri/dioscuri/#methods_5","text":"","title":"Methods"},{"location":"reference/dioscuri/dioscuri/#to_string_4","text":"def to_string ( self ) View Source def to_string ( self ): # Order is important : parameters = [ self . type_character , self . rack_label , self . rack_id , self . rack_type , str ( self . position ), self . tube_id , str ( self . volume ), self . liquid_class , self . tip_type , self . tip_mask , self . forced_rack_type , ] record_as_string = \";\" . join ( parameters ) return record_as_string","title":"to_string"},{"location":"reference/dioscuri/dioscuri/#reagentdistribution","text":"class ReagentDistribution ( SrcRackLabel , SrcRackID , SrcRackType , SrcPosStart , SrcPosEnd , DestRackLabel , DestRackID , DestRackType , DestPosStart , DestPosEnd , Volume , LiquidClass = '' , NoOfDitiReuses = 1 , NoOfMultiDisp = 1 , Direction = 0 , ExcludeDestWell = '' ) The Reagent Distribution record. Parameters SrcRackLabel Label ( str ) of source labware. Maximum 32 characters. SrcRackID Source labware barcode ( str ). Maximum 32 characters. SrcRackType Source labware type ( str ): configuration name. Maximum 32 characters. SrcPosStart First well to be used in the source labware ( int ). Range: 1 .. number of wells. SrcPosEnd Last well to be used in the source labware ( int ). Range: 1 .. number of wells. DestRackLabel Label ( str ) of destination labware. Maximum 32 characters. DestRackID Destination labware barcode ( str ). Maximum 32 characters. DestRackType Destination labware type ( str ): configuration name. Maximum 32 characters. DestPosStart First well to be used in the destination labware ( int ). Range: 1 .. number of wells. DestPosEnd Last well to be used in the destination labware ( int ). Range: 1 .. number of wells. Volume Dispense volume ( int ) in the destination labware in \u03bcl (microliter). Range: 0..7158278. LiquidClass Optional ( str ). Overwrites the liquid class specified in the Tecan EVOware Worklist command. Maximum 32 characters. NoOfDitiReuses Optional ( int ). Maximum number of DiTi reuses allowed (default 1 = no DiTi reuse). NoOfMultiDisp Optional ( int ). Maximum number of dispenses in a multidispense sequence (default 1 = no multi-dispense). Direction Optional ( int ). Pipetting direction (0 = left to right, 1 = right to left; default = 0). ExcludeDestWell Optional ( str ). List of wells in destination labware to be excluded from pipetting. View Source class ReagentDistribution : \"\"\"The Reagent Distribution record. **Parameters** **SrcRackLabel** > Label (`str`) of source labware. Maximum 32 characters. **SrcRackID** > Source labware barcode (`str`). Maximum 32 characters. **SrcRackType** > Source labware type (`str`): configuration name. Maximum 32 characters. **SrcPosStart** > First well to be used in the source labware (`int`). Range: 1 .. number of wells. **SrcPosEnd** > Last well to be used in the source labware (`int`). Range: 1 .. number of wells. **DestRackLabel** > Label (`str`) of destination labware. Maximum 32 characters. **DestRackID** > Destination labware barcode (`str`). Maximum 32 characters. **DestRackType** > Destination labware type (`str`): configuration name. Maximum 32 characters. **DestPosStart** > First well to be used in the destination labware (`int`). > Range: 1 .. number of wells. **DestPosEnd** > Last well to be used in the destination labware (`int`). > Range: 1 .. number of wells. **Volume** > Dispense volume (`int`) in the destination labware in \u03bcl (microliter). > Range: 0..7158278. **LiquidClass** > Optional (`str`). Overwrites the liquid class specified in the Tecan EVOware Worklist command. Maximum 32 characters. **NoOfDitiReuses** > Optional (`int`). Maximum number of DiTi reuses allowed > (default 1 = no DiTi reuse). **NoOfMultiDisp** > Optional (`int`). Maximum number of dispenses in a multidispense sequence > (default 1 = no multi-dispense). **Direction** > Optional (`int`). Pipetting direction > (0 = left to right, 1 = right to left; default = 0). **ExcludeDestWell** > Optional (`str`). List of wells in destination labware to be excluded from > pipetting. \"\"\" def __init__ ( self , SrcRackLabel , SrcRackID , SrcRackType , SrcPosStart , SrcPosEnd , DestRackLabel , DestRackID , DestRackType , DestPosStart , DestPosEnd , Volume , LiquidClass = \"\" , NoOfDitiReuses = 1 , NoOfMultiDisp = 1 , Direction = 0 , ExcludeDestWell = \"\" , ): self . type_character = \"R\" self . SrcRackLabel = SrcRackLabel self . SrcRackID = SrcRackID self . SrcRackType = SrcRackType self . SrcPosStart = str ( SrcPosStart ) self . SrcPosEnd = str ( SrcPosEnd ) self . DestRackLabel = DestRackLabel self . DestRackID = DestRackID self . DestRackType = DestRackType self . DestPosStart = str ( DestPosStart ) self . DestPosEnd = str ( DestPosEnd ) self . Volume = str ( Volume ) self . LiquidClass = LiquidClass self . NoOfDitiReuses = str ( NoOfDitiReuses ) self . NoOfMultiDisp = str ( NoOfMultiDisp ) self . Direction = str ( Direction ) self . ExcludeDestWell = ExcludeDestWell def to_string ( self ): # Order is important: parameters = [ self . type_character , self . SrcRackLabel , self . SrcRackID , self . SrcRackType , self . SrcPosStart , self . SrcPosEnd , self . DestRackLabel , self . DestRackID , self . DestRackType , self . DestPosStart , self . DestPosEnd , self . Volume , self . LiquidClass , self . NoOfDitiReuses , self . NoOfMultiDisp , self . Direction , self . ExcludeDestWell , ] record_as_string = \";\" . join ( parameters ) return record_as_string","title":"ReagentDistribution"},{"location":"reference/dioscuri/dioscuri/#methods_6","text":"","title":"Methods"},{"location":"reference/dioscuri/dioscuri/#to_string_5","text":"def to_string ( self ) View Source def to_string ( self ): # Order is important : parameters = [ self . type_character , self . SrcRackLabel , self . SrcRackID , self . SrcRackType , self . SrcPosStart , self . SrcPosEnd , self . DestRackLabel , self . DestRackID , self . DestRackType , self . DestPosStart , self . DestPosEnd , self . Volume , self . LiquidClass , self . NoOfDitiReuses , self . NoOfMultiDisp , self . Direction , self . ExcludeDestWell , ] record_as_string = \";\" . join ( parameters ) return record_as_string","title":"to_string"},{"location":"reference/dioscuri/dioscuri/#setdititype","text":"class SetDITIType ( diti_index ) The Set DiTi Type record. The Set DiTi Type record can only be used at the very beginning of the worklist or directly after a Break record. Parameters DiTi_Index The index of DiTi Type ( str ). Used to switch DiTi types from within a worklist. View Source class SetDITIType : \"\"\"The Set DiTi Type record. The Set DiTi Type record can only be used at the very beginning of the worklist or directly after a Break record. **Parameters** **DiTi_Index** > The index of DiTi Type (`str`). Used to switch DiTi types from within a worklist. \"\"\" def __init__ ( self , diti_index ): self . diti_index = diti_index self . type_character = \"S\" def to_string ( self ): \"\"\"Convert record into string representation.\"\"\" parameters = [ self . type_character , self . diti_index ] record_as_string = \";\" . join ( parameters ) return record_as_string","title":"SetDITIType"},{"location":"reference/dioscuri/dioscuri/#methods_7","text":"","title":"Methods"},{"location":"reference/dioscuri/dioscuri/#to_string_6","text":"def to_string ( self ) Convert record into string representation. View Source def to_string ( self ): \"\"\"Convert record into string representation.\"\"\" parameters = [ self . type_character , self . diti_index ] record_as_string = \";\" . join ( parameters ) return record_as_string","title":"to_string"},{"location":"reference/dioscuri/dioscuri/#washtiporreplacediti","text":"class WashTipOrReplaceDITI ( scheme = None ) Class for WashTip or ReplaceDITI records. Parameters scheme Number ( int ) of wash scheme to use. Default None , which uses the first wash scheme. View Source class WashTipOrReplaceDITI : \"\"\"Class for WashTip or ReplaceDITI records. **Parameters** **scheme** > Number (`int`) of wash scheme to use. Default `None`, which uses the first wash scheme. \"\"\" def __init__ ( self , scheme = None ): if scheme is None : self . scheme = \"\" else : if scheme not in [ 1 , 2 , 3 , 4 ]: raise ValueError ( \"Scheme must be between 1 and 4.\" ) self . scheme = str ( scheme ) self . type_character = \"W\" def to_string ( self ): \"\"\"Convert record into string representation.\"\"\" record_as_string = self . type_character + self . scheme + \";\" return record_as_string","title":"WashTipOrReplaceDITI"},{"location":"reference/dioscuri/dioscuri/#methods_8","text":"","title":"Methods"},{"location":"reference/dioscuri/dioscuri/#to_string_7","text":"def to_string ( self ) Convert record into string representation. View Source def to_string ( self ): \"\"\"Convert record into string representation.\"\"\" record_as_string = self . type_character + self . scheme + \";\" return record_as_string","title":"to_string"},{"location":"reference/dioscuri/version/","text":"Module dioscuri.version View Source __version__ = \"0.1.2\"","title":"Version"},{"location":"reference/dioscuri/version/#module-dioscuriversion","text":"View Source __version__ = \"0.1.2\"","title":"Module dioscuri.version"}]}